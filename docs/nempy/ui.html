<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nempy.ui API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nempy.ui</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import binascii
import configparser
import logging
import os
import random
from enum import Enum
from hashlib import blake2b
from typing import Optional, Dict, Tuple, Union, List, Type

import bcrypt
import inquirer
import stdiomask
from bip_utils import Bip39MnemonicGenerator, Bip39Languages
from nempy.config import C
from nempy.sym import network
from nempy.sym.constants import NetworkType, TransactionStatus
from nempy.sym.network import TransactionResponse
from nempy.user_data import AccountData, GenerationType, UserData
from nempy.user_data import ProfileData
from password_strength import PasswordPolicy


logger = logging.getLogger(__name__)


class PasswordPolicyError(Exception):
    pass


class RepeatPasswordError(Exception):
    pass


class UDTypes(Enum):
    PROFILE = &#39;profile&#39;
    ACCOUNT = &#39;account&#39;


def print_warning():
    print(f&#34;&#34;&#34; {C.ORANGE}
                                !!! Important !!!
 Save the mnemonic, it will be needed to restore access to the wallet in case of password loss
       Where to store can be found here - https://en.bitcoinwiki.org/wiki/Mnemonic_phrase
!!!Do not share your secret key and mnemonic with anyone, it guarantees access to your funds!!!
                                       !!!{C.END}
    &#34;&#34;&#34;)


class UD:

    cls: Type[UserData]
    type_ud: UDTypes
    ud_dir: str
    config = configparser.ConfigParser()

    def __init__(self, config_file: str, profiles_dir: Optional[str], accounts_dir: Optional[str]):
        self.config_file = config_file
        if self.type_ud == UDTypes.PROFILE:
            self.ud_dir = profiles_dir
            self.cls = ProfileData
        elif self.type_ud == UDTypes.ACCOUNT:
            self.ud_dir = accounts_dir
            self.cls = AccountData

    @property
    def user_data(self) -&gt; Optional[UserData]:
        self.config.read(self.config_file)
        ud_name = self.config[self.type_ud.value][&#39;default&#39;]
        uds = self.load_uds()
        ud = uds.get(ud_name)
        return ud

    def load_uds(self) -&gt; Dict[str, UserData]:
        uds = {}
        profiles_paths = os.listdir(self.ud_dir)
        for pp in profiles_paths:
            path = os.path.join(self.ud_dir, pp)
            ud = self.cls.read(path)
            uds[os.path.splitext(pp)[0]] = ud
        return uds

    def set_default_ud(self, ud: UserData):
        self.config.read(self.config_file)
        self.config[self.type_ud.value][&#39;default&#39;] = ud.name
        with open(self.config_file, &#39;w&#39;) as configfile:
            self.config.write(configfile)

    def get_default_ud_name(self) -&gt; str:
        self.config.read(self.config_file)
        ud_name = self.config[self.type_ud.value][&#39;default&#39;]
        return ud_name


class AccountI(UD):

    def __init__(self, config_file: str, accounts_dir: str):
        self.type_ud = UDTypes.ACCOUNT
        super().__init__(config_file, None, accounts_dir)

    @property
    def data(self) -&gt; Optional[AccountData]:
        return self.user_data

    def load_accounts(self) -&gt; Dict[str, AccountData]:
        return self.load_uds()

    def set_default_account(self, account: AccountData):
        self.set_default_ud(account)


class ProfileI(UD):

    def __init__(self, config_file: str, profiles_dir: str, accounts_dir: str):
        self.type_ud = UDTypes.PROFILE
        self.account_i = AccountI(config_file, accounts_dir)
        super().__init__(config_file, profiles_dir, None)
        accounts_data = self.load_accounts()
        if (self.account.data is None and accounts_data) \
                or (self.account.data is not None and self.account.data.name not in accounts_data):
            account_data = AccountUI.ui_default_account(accounts_data)
            self.set_default_account(account_data)

    @property
    def data(self) -&gt; Optional[ProfileData]:
        return self.user_data

    def load_profiles(self) -&gt; Dict[str, ProfileData]:
        return self.load_uds()

    def set_default_profile(self, profile: ProfileData):
        self.set_default_ud(profile)

    @property
    def account(self) -&gt; AccountI:
        return self.account_i

    def load_accounts(self) -&gt; Dict[str, AccountData]:
        accounts_data = self.account_i.load_accounts()
        accounts_data = {key: account for key, account in accounts_data.items() if account.profile == self.data.name}
        return accounts_data

    def set_default_account(self, account: AccountData):
        self.account_i.set_default_account(account)


class AccountUI(AccountI):

    @staticmethod
    def ui_init_general_params(network_type: NetworkType, accounts_dir: str, is_default: bool = False) -&gt; Tuple[str, str, int, bool]:
        while True:
            name = input(&#39;Enter the account name: &#39;)
            if name != &#39;&#39;:
                account_path = os.path.join(accounts_dir, name + &#39;.account&#39;)
                if os.path.exists(account_path):
                    print(&#39;An account with the same name already exists, please select a different name&#39;)
                    continue
                break
            print(&#39;The name cannot be empty.&#39;)
        if not is_default:
            answer = input(f&#39;Set `{name}` account as default? [Y/n]: &#39;) or &#39;y&#39;
            if answer.lower() == &#39;y&#39;:
                is_default = True
        if network_type == NetworkType.MAIN_NET:
            bip32_coin_id = 4343
        elif network_type == NetworkType.TEST_NET:
            bip32_coin_id = 1
        else:
            raise ValueError(&#39;Invalid URL or network not supported&#39;)
        return account_path, name, bip32_coin_id, is_default

    @staticmethod
    def iu_create_account(profile_data: ProfileData,
                          accounts_dir: str,
                          is_default: bool = False,
                          is_import: bool = False) -&gt; Tuple[Optional[AccountData], bool]:
        account_path, name, bip32_coin_id, is_default = AccountUI.ui_init_general_params(profile_data.network_type, accounts_dir, is_default)
        password = ProfileUI.ui_check_pass(profile_data, attempts=3)
        if password is not None:
            if is_import:
                gen_type = AccountUI.ui_generation_type_inquirer()
                if gen_type == GenerationType.MNEMONIC:
                    account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=True)
                elif gen_type == GenerationType.PRIVATE_KEY:
                    raise NotImplementedError(
                        &#39;The functionality of building an account from a private key is not implemented&#39;)
                else:
                    raise NotImplementedError(
                        f&#39;The functionality of building an account from a {gen_type.name} key is not implemented&#39;)
            else:
                account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=is_import)
            account_data.name = name
            account_data.profile = profile_data.name
            AccountUI.save_and_check(account_data, account_path, password)
            return account_data, is_default
        else:
            return None, is_default

    @staticmethod
    def save_and_check(account_data: AccountData, account_path: str, password: str):
        account_data.encrypt(password).write(account_path)
        print(f&#39;\nAccount created at: {account_path}&#39;)
        # checking the ability to read and display information about the account
        account_data = AccountData.read(account_path).decrypt(password)
        print(account_data)
        print_warning()
        return account_data

    @staticmethod
    def ui_default_account(accounts: Dict[str, AccountData]):
        questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default account&#34;, choices=accounts.keys(), ), ]
        answers = inquirer.prompt(questions)
        if answers is None:
            exit(1)
        account = accounts[answers[&#39;name&#39;]]
        return account  # -&gt; set_default_account(account)

    @staticmethod
    def ui_generation_type_inquirer() -&gt; GenerationType:
        questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an import type?&#34;, choices=[&#34;Mnemonic&#34;, &#34;Private Key&#34;], ), ]
        answers = inquirer.prompt(questions)
        import_type = answers[&#39;type&#39;]
        if import_type == &#39;Private Key&#39;:
            return GenerationType.PRIVATE_KEY
        return GenerationType.MNEMONIC

    @staticmethod
    def ui_history_inquirer(address: str = None, page_size: int = 10):
        conf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                                   page_size=page_size,
                                                                                   transaction_status=TransactionStatus.CONFIRMED_ADDED)
        unconf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                                     page_size=page_size,
                                                                                     transaction_status=TransactionStatus.UNCONFIRMED_ADDED)
        transactions = unconf_transactions + conf_transactions
        short_names = {}
        for transaction in transactions:
            is_mosaic = &#39;∴&#39; if len(transaction.transaction.mosaics) &gt; 1 else &#39;&#39;
            message = &#39;🖂&#39; if transaction.transaction.message is not None else &#39; &#39;
            direction = &#39;+&#39; if transaction.transaction.recipientAddress == address else &#39;−&#39;
            status = &#39;🗸&#39; if transaction.status == TransactionStatus.CONFIRMED_ADDED.value else &#39;?&#39;
            mosaic = next(iter(transaction.transaction.mosaics), &#39;&#39;)
            short_name = f&#39;{status} {transaction.transaction.recipientAddress} | {transaction.meta.height} | {transaction.transaction.deadline} |{message} |{direction}{mosaic} {is_mosaic}&#39;
            short_names[short_name] = transaction
        _short_names = list(short_names.keys())
        _short_names.append(&#39;Exit&#39;)
        while True:
            questions = [
                inquirer.List(
                    &#34;transaction&#34;,
                    message=&#34;Select an transaction?&#34;,
                    choices=_short_names,
                    carousel=True
                ),
            ]
            answers = inquirer.prompt(questions)
            transaction = answers[&#39;transaction&#39;]
            if transaction == &#39;Exit&#39;:
                exit(0)
            print(short_names[transaction])

    @staticmethod
    def ui_keyprint_entropy():
        random_char_set = &#39;&#39;
        print(&#39;Write something (random character set), the input will be interrupted automatically&#39;)
        attempts = list(range(random.randint(3, 5)))
        for i in attempts:
            something = input(f&#39;Something else ({len(attempts) - i}): &#39;)
            if not something:
                print(&#39;Only a non-empty line will have to be repeated :(&#39;)
                attempts.append(len(attempts))
                continue
            random_char_set += something
        return random_char_set

    @staticmethod
    def ui_account_inquirer(accounts_names):
        addresses = [account for account in accounts_names]
        questions = [inquirer.List(&#34;address&#34;, message=&#34;Select an import type?&#34;, choices=addresses,), ]
        answers = inquirer.prompt(questions)
        account_name = answers[&#39;address&#39;]
        return account_name

    @classmethod
    def ui_account_by_mnemonic(cls, network_type: NetworkType, bip32_coin_id: int, is_import: bool = False) -&gt; &#39;AccountData&#39;:
        if is_import:
            mnemonic = stdiomask.getpass(&#39;Enter a mnemonic passphrase. Words must be separated by spaces: &#39;)
        else:
            random_char_set = cls.ui_keyprint_entropy()
            entropy_bytes_hex = blake2b(random_char_set.encode(), digest_size=32).hexdigest().encode()
            mnemonic = Bip39MnemonicGenerator(Bip39Languages.ENGLISH).FromEntropy(binascii.unhexlify(entropy_bytes_hex))

        accounts = AccountData.accounts_pool_by_mnemonic(network_type, bip32_coin_id, mnemonic)
        account_name = cls.ui_account_inquirer(accounts.keys())
        return accounts[account_name]


class ProfileUI(ProfileI):

    @staticmethod
    def ui_default_profile(profiles: Dict[str, ProfileData]) -&gt; ProfileData:
        names = {profile.name + f&#39; [{profile.network_type.name}]&#39;: profile.name for profile in profiles.values()}
        questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default profile&#34;, choices=names.keys(),), ]
        answers = inquirer.prompt(questions)
        if answers is None:
            exit(1)
        name = names[answers[&#39;name&#39;]]
        profile_data = profiles[name]
        network.node_selector.network_type = profile_data.network_type
        return profile_data  # -&gt; set_default_profile(profile)

    @classmethod
    def ui_create_profile(cls, profiles_dir: str, config_file: str) -&gt; Tuple[ProfileData, str]:
        name, path = cls.ui_profile_name(profiles_dir)
        network_type = cls.ui_network_type()
        new_pass = cls.ui_new_pass(10)
        pass_hash = bcrypt.hashpw(new_pass.encode(&#39;utf-8&#39;), bcrypt.gensalt(12))
        accounts_dir = os.path.join(os.path.dirname(profiles_dir), &#39;accounts&#39;)
        profile = ProfileData(name=name,
                              network_type=network_type,
                              pass_hash=pass_hash,
                              accounts_dir=accounts_dir,
                              config_file=config_file)
        return profile, path

    @staticmethod
    def ui_check_pass(profile_data: ProfileData, attempts: int = 1) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Verifies the password from the profile
        :return: password or None if password is failed
        &#34;&#34;&#34;
        for i in range(attempts):
            password = stdiomask.getpass(f&#39;({attempts - i}) Enter your `{profile_data.name} [{profile_data.network_type.name}]` profile password: &#39;)
            if bcrypt.checkpw(password.encode(&#39;utf-8&#39;), profile_data.pass_hash):
                return password
            if i != attempts - 1:
                print(f&#39;Incorrect password. Try again)&#39;)
        logger.error(&#39;Incorrect password&#39;)
        return None

    @staticmethod
    def ui_is_default(name):
        answer = input(f&#39;Set `{name}` profile as default? [Y/n]: &#39;) or &#39;y&#39;
        if answer.lower() == &#39;y&#39;:
            return True
        return False

    @staticmethod
    def ui_profile_name(profiles_dir, attempts: int = 5):
        name = None
        for i in range(attempts):
            name = input(f&#39;({attempts - i}) Enter profile name: &#39;)
            if &#39;.&#39; in name:
                print(&#39;Dot is not a valid character for filename&#39;)
                continue
            path = os.path.join(profiles_dir, f&#39;{name}.profile&#39;)
            if name == &#39;&#39;:
                print(&#39;The name cannot be empty&#39;)
            elif os.path.exists(path):
                print(f&#39;A profile named `{name}` already exists&#39;)
            else:
                return name, path
        raise ValueError(f&#39;Incorrect name for new profile - `{name}`&#39;)

    @staticmethod
    def ui_network_type() -&gt; NetworkType:
        questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an network type?&#34;, choices=[&#34;TEST_NET&#34;, &#34;MAIN_NET&#34;],), ]
        answers = inquirer.prompt(questions)
        network_type = answers[&#39;type&#39;]
        if network_type == &#39;MAIN_NET&#39;:
            network_type = NetworkType.MAIN_NET
        elif network_type == &#39;TEST_NET&#39;:
            network_type = NetworkType.TEST_NET
        else:
            raise TypeError(&#39;Unknown network type&#39;)
        return network_type

    @staticmethod
    def ui_new_pass(n_attempts: int):
        policy = PasswordPolicy.from_names(
            length=8,  # min length: 8
            uppercase=1,  # need min. 1 uppercase letters
            numbers=2,  # need min. 2 digits
            special=1,  # need min. 1 special characters
            nonletters=2,  # need min. 2 non-letter characters (digits, specials, anything)
        )
        new_password = None
        not_in_policies = True
        for i in range(n_attempts):
            new_password = stdiomask.getpass(f&#39;Enter your new account password {policy.test(&#34;&#34;)}: &#39;)
            not_in_policies = policy.test(new_password)
            if not_in_policies:
                print(not_in_policies)
            else:
                break
        if not_in_policies:
            raise PasswordPolicyError(not_in_policies)
        return ProfileUI.ui_repeat_password(n_attempts, new_password)

    @staticmethod
    def ui_repeat_password(n_attempts: int, password):
        for i in range(n_attempts):
            repeat_password = stdiomask.getpass(f&#39;Repeat password for confirmation: &#39;)
            if repeat_password != password:
                print(f&#39;Try again, attempts left {n_attempts - i}&#39;)
            else:
                return password
        raise RepeatPasswordError(&#39;Failed to confirm password on re-entry&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="nempy.ui.print_warning"><code class="name flex">
<span>def <span class="ident">print_warning</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_warning():
    print(f&#34;&#34;&#34; {C.ORANGE}
                                !!! Important !!!
 Save the mnemonic, it will be needed to restore access to the wallet in case of password loss
       Where to store can be found here - https://en.bitcoinwiki.org/wiki/Mnemonic_phrase
!!!Do not share your secret key and mnemonic with anyone, it guarantees access to your funds!!!
                                       !!!{C.END}
    &#34;&#34;&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nempy.ui.AccountI"><code class="flex name class">
<span>class <span class="ident">AccountI</span></span>
<span>(</span><span>config_file: str, accounts_dir: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountI(UD):

    def __init__(self, config_file: str, accounts_dir: str):
        self.type_ud = UDTypes.ACCOUNT
        super().__init__(config_file, None, accounts_dir)

    @property
    def data(self) -&gt; Optional[AccountData]:
        return self.user_data

    def load_accounts(self) -&gt; Dict[str, AccountData]:
        return self.load_uds()

    def set_default_account(self, account: AccountData):
        self.set_default_ud(account)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nempy.ui.UD" href="#nempy.ui.UD">UD</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nempy.ui.AccountUI" href="#nempy.ui.AccountUI">AccountUI</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.AccountI.cls"><code class="name">var <span class="ident">cls</span> : Type[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.AccountI.type_ud"><code class="name">var <span class="ident">type_ud</span> : <a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.AccountI.ud_dir"><code class="name">var <span class="ident">ud_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nempy.ui.AccountI.data"><code class="name">var <span class="ident">data</span> : Optional[<a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; Optional[AccountData]:
    return self.user_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nempy.ui.AccountI.load_accounts"><code class="name flex">
<span>def <span class="ident">load_accounts</span></span>(<span>self) ‑> Dict[str, <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_accounts(self) -&gt; Dict[str, AccountData]:
    return self.load_uds()</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountI.set_default_account"><code class="name flex">
<span>def <span class="ident">set_default_account</span></span>(<span>self, account: <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_account(self, account: AccountData):
    self.set_default_ud(account)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.ui.AccountUI"><code class="flex name class">
<span>class <span class="ident">AccountUI</span></span>
<span>(</span><span>config_file: str, accounts_dir: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountUI(AccountI):

    @staticmethod
    def ui_init_general_params(network_type: NetworkType, accounts_dir: str, is_default: bool = False) -&gt; Tuple[str, str, int, bool]:
        while True:
            name = input(&#39;Enter the account name: &#39;)
            if name != &#39;&#39;:
                account_path = os.path.join(accounts_dir, name + &#39;.account&#39;)
                if os.path.exists(account_path):
                    print(&#39;An account with the same name already exists, please select a different name&#39;)
                    continue
                break
            print(&#39;The name cannot be empty.&#39;)
        if not is_default:
            answer = input(f&#39;Set `{name}` account as default? [Y/n]: &#39;) or &#39;y&#39;
            if answer.lower() == &#39;y&#39;:
                is_default = True
        if network_type == NetworkType.MAIN_NET:
            bip32_coin_id = 4343
        elif network_type == NetworkType.TEST_NET:
            bip32_coin_id = 1
        else:
            raise ValueError(&#39;Invalid URL or network not supported&#39;)
        return account_path, name, bip32_coin_id, is_default

    @staticmethod
    def iu_create_account(profile_data: ProfileData,
                          accounts_dir: str,
                          is_default: bool = False,
                          is_import: bool = False) -&gt; Tuple[Optional[AccountData], bool]:
        account_path, name, bip32_coin_id, is_default = AccountUI.ui_init_general_params(profile_data.network_type, accounts_dir, is_default)
        password = ProfileUI.ui_check_pass(profile_data, attempts=3)
        if password is not None:
            if is_import:
                gen_type = AccountUI.ui_generation_type_inquirer()
                if gen_type == GenerationType.MNEMONIC:
                    account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=True)
                elif gen_type == GenerationType.PRIVATE_KEY:
                    raise NotImplementedError(
                        &#39;The functionality of building an account from a private key is not implemented&#39;)
                else:
                    raise NotImplementedError(
                        f&#39;The functionality of building an account from a {gen_type.name} key is not implemented&#39;)
            else:
                account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=is_import)
            account_data.name = name
            account_data.profile = profile_data.name
            AccountUI.save_and_check(account_data, account_path, password)
            return account_data, is_default
        else:
            return None, is_default

    @staticmethod
    def save_and_check(account_data: AccountData, account_path: str, password: str):
        account_data.encrypt(password).write(account_path)
        print(f&#39;\nAccount created at: {account_path}&#39;)
        # checking the ability to read and display information about the account
        account_data = AccountData.read(account_path).decrypt(password)
        print(account_data)
        print_warning()
        return account_data

    @staticmethod
    def ui_default_account(accounts: Dict[str, AccountData]):
        questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default account&#34;, choices=accounts.keys(), ), ]
        answers = inquirer.prompt(questions)
        if answers is None:
            exit(1)
        account = accounts[answers[&#39;name&#39;]]
        return account  # -&gt; set_default_account(account)

    @staticmethod
    def ui_generation_type_inquirer() -&gt; GenerationType:
        questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an import type?&#34;, choices=[&#34;Mnemonic&#34;, &#34;Private Key&#34;], ), ]
        answers = inquirer.prompt(questions)
        import_type = answers[&#39;type&#39;]
        if import_type == &#39;Private Key&#39;:
            return GenerationType.PRIVATE_KEY
        return GenerationType.MNEMONIC

    @staticmethod
    def ui_history_inquirer(address: str = None, page_size: int = 10):
        conf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                                   page_size=page_size,
                                                                                   transaction_status=TransactionStatus.CONFIRMED_ADDED)
        unconf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                                     page_size=page_size,
                                                                                     transaction_status=TransactionStatus.UNCONFIRMED_ADDED)
        transactions = unconf_transactions + conf_transactions
        short_names = {}
        for transaction in transactions:
            is_mosaic = &#39;∴&#39; if len(transaction.transaction.mosaics) &gt; 1 else &#39;&#39;
            message = &#39;🖂&#39; if transaction.transaction.message is not None else &#39; &#39;
            direction = &#39;+&#39; if transaction.transaction.recipientAddress == address else &#39;−&#39;
            status = &#39;🗸&#39; if transaction.status == TransactionStatus.CONFIRMED_ADDED.value else &#39;?&#39;
            mosaic = next(iter(transaction.transaction.mosaics), &#39;&#39;)
            short_name = f&#39;{status} {transaction.transaction.recipientAddress} | {transaction.meta.height} | {transaction.transaction.deadline} |{message} |{direction}{mosaic} {is_mosaic}&#39;
            short_names[short_name] = transaction
        _short_names = list(short_names.keys())
        _short_names.append(&#39;Exit&#39;)
        while True:
            questions = [
                inquirer.List(
                    &#34;transaction&#34;,
                    message=&#34;Select an transaction?&#34;,
                    choices=_short_names,
                    carousel=True
                ),
            ]
            answers = inquirer.prompt(questions)
            transaction = answers[&#39;transaction&#39;]
            if transaction == &#39;Exit&#39;:
                exit(0)
            print(short_names[transaction])

    @staticmethod
    def ui_keyprint_entropy():
        random_char_set = &#39;&#39;
        print(&#39;Write something (random character set), the input will be interrupted automatically&#39;)
        attempts = list(range(random.randint(3, 5)))
        for i in attempts:
            something = input(f&#39;Something else ({len(attempts) - i}): &#39;)
            if not something:
                print(&#39;Only a non-empty line will have to be repeated :(&#39;)
                attempts.append(len(attempts))
                continue
            random_char_set += something
        return random_char_set

    @staticmethod
    def ui_account_inquirer(accounts_names):
        addresses = [account for account in accounts_names]
        questions = [inquirer.List(&#34;address&#34;, message=&#34;Select an import type?&#34;, choices=addresses,), ]
        answers = inquirer.prompt(questions)
        account_name = answers[&#39;address&#39;]
        return account_name

    @classmethod
    def ui_account_by_mnemonic(cls, network_type: NetworkType, bip32_coin_id: int, is_import: bool = False) -&gt; &#39;AccountData&#39;:
        if is_import:
            mnemonic = stdiomask.getpass(&#39;Enter a mnemonic passphrase. Words must be separated by spaces: &#39;)
        else:
            random_char_set = cls.ui_keyprint_entropy()
            entropy_bytes_hex = blake2b(random_char_set.encode(), digest_size=32).hexdigest().encode()
            mnemonic = Bip39MnemonicGenerator(Bip39Languages.ENGLISH).FromEntropy(binascii.unhexlify(entropy_bytes_hex))

        accounts = AccountData.accounts_pool_by_mnemonic(network_type, bip32_coin_id, mnemonic)
        account_name = cls.ui_account_inquirer(accounts.keys())
        return accounts[account_name]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nempy.ui.AccountI" href="#nempy.ui.AccountI">AccountI</a></li>
<li><a title="nempy.ui.UD" href="#nempy.ui.UD">UD</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.AccountUI.cls"><code class="name">var <span class="ident">cls</span> : Type[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.AccountUI.type_ud"><code class="name">var <span class="ident">type_ud</span> : <a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.AccountUI.ud_dir"><code class="name">var <span class="ident">ud_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nempy.ui.AccountUI.iu_create_account"><code class="name flex">
<span>def <span class="ident">iu_create_account</span></span>(<span>profile_data: <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>, accounts_dir: str, is_default: bool = False, is_import: bool = False) ‑> Tuple[Optional[<a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>], bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def iu_create_account(profile_data: ProfileData,
                      accounts_dir: str,
                      is_default: bool = False,
                      is_import: bool = False) -&gt; Tuple[Optional[AccountData], bool]:
    account_path, name, bip32_coin_id, is_default = AccountUI.ui_init_general_params(profile_data.network_type, accounts_dir, is_default)
    password = ProfileUI.ui_check_pass(profile_data, attempts=3)
    if password is not None:
        if is_import:
            gen_type = AccountUI.ui_generation_type_inquirer()
            if gen_type == GenerationType.MNEMONIC:
                account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=True)
            elif gen_type == GenerationType.PRIVATE_KEY:
                raise NotImplementedError(
                    &#39;The functionality of building an account from a private key is not implemented&#39;)
            else:
                raise NotImplementedError(
                    f&#39;The functionality of building an account from a {gen_type.name} key is not implemented&#39;)
        else:
            account_data = AccountUI.ui_account_by_mnemonic(profile_data.network_type, bip32_coin_id, is_import=is_import)
        account_data.name = name
        account_data.profile = profile_data.name
        AccountUI.save_and_check(account_data, account_path, password)
        return account_data, is_default
    else:
        return None, is_default</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.save_and_check"><code class="name flex">
<span>def <span class="ident">save_and_check</span></span>(<span>account_data: <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>, account_path: str, password: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_and_check(account_data: AccountData, account_path: str, password: str):
    account_data.encrypt(password).write(account_path)
    print(f&#39;\nAccount created at: {account_path}&#39;)
    # checking the ability to read and display information about the account
    account_data = AccountData.read(account_path).decrypt(password)
    print(account_data)
    print_warning()
    return account_data</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_account_by_mnemonic"><code class="name flex">
<span>def <span class="ident">ui_account_by_mnemonic</span></span>(<span>network_type: <a title="nempy.sym.constants.NetworkType" href="sym/constants.html#nempy.sym.constants.NetworkType">NetworkType</a>, bip32_coin_id: int, is_import: bool = False) ‑> <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ui_account_by_mnemonic(cls, network_type: NetworkType, bip32_coin_id: int, is_import: bool = False) -&gt; &#39;AccountData&#39;:
    if is_import:
        mnemonic = stdiomask.getpass(&#39;Enter a mnemonic passphrase. Words must be separated by spaces: &#39;)
    else:
        random_char_set = cls.ui_keyprint_entropy()
        entropy_bytes_hex = blake2b(random_char_set.encode(), digest_size=32).hexdigest().encode()
        mnemonic = Bip39MnemonicGenerator(Bip39Languages.ENGLISH).FromEntropy(binascii.unhexlify(entropy_bytes_hex))

    accounts = AccountData.accounts_pool_by_mnemonic(network_type, bip32_coin_id, mnemonic)
    account_name = cls.ui_account_inquirer(accounts.keys())
    return accounts[account_name]</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_account_inquirer"><code class="name flex">
<span>def <span class="ident">ui_account_inquirer</span></span>(<span>accounts_names)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_account_inquirer(accounts_names):
    addresses = [account for account in accounts_names]
    questions = [inquirer.List(&#34;address&#34;, message=&#34;Select an import type?&#34;, choices=addresses,), ]
    answers = inquirer.prompt(questions)
    account_name = answers[&#39;address&#39;]
    return account_name</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_default_account"><code class="name flex">
<span>def <span class="ident">ui_default_account</span></span>(<span>accounts: Dict[str, <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_default_account(accounts: Dict[str, AccountData]):
    questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default account&#34;, choices=accounts.keys(), ), ]
    answers = inquirer.prompt(questions)
    if answers is None:
        exit(1)
    account = accounts[answers[&#39;name&#39;]]
    return account  # -&gt; set_default_account(account)</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_generation_type_inquirer"><code class="name flex">
<span>def <span class="ident">ui_generation_type_inquirer</span></span>(<span>) ‑> <a title="nempy.user_data.GenerationType" href="user_data.html#nempy.user_data.GenerationType">GenerationType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_generation_type_inquirer() -&gt; GenerationType:
    questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an import type?&#34;, choices=[&#34;Mnemonic&#34;, &#34;Private Key&#34;], ), ]
    answers = inquirer.prompt(questions)
    import_type = answers[&#39;type&#39;]
    if import_type == &#39;Private Key&#39;:
        return GenerationType.PRIVATE_KEY
    return GenerationType.MNEMONIC</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_history_inquirer"><code class="name flex">
<span>def <span class="ident">ui_history_inquirer</span></span>(<span>address: str = None, page_size: int = 10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_history_inquirer(address: str = None, page_size: int = 10):
    conf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                               page_size=page_size,
                                                                               transaction_status=TransactionStatus.CONFIRMED_ADDED)
    unconf_transactions: List[TransactionResponse] = network.search_transactions(address=address,
                                                                                 page_size=page_size,
                                                                                 transaction_status=TransactionStatus.UNCONFIRMED_ADDED)
    transactions = unconf_transactions + conf_transactions
    short_names = {}
    for transaction in transactions:
        is_mosaic = &#39;∴&#39; if len(transaction.transaction.mosaics) &gt; 1 else &#39;&#39;
        message = &#39;🖂&#39; if transaction.transaction.message is not None else &#39; &#39;
        direction = &#39;+&#39; if transaction.transaction.recipientAddress == address else &#39;−&#39;
        status = &#39;🗸&#39; if transaction.status == TransactionStatus.CONFIRMED_ADDED.value else &#39;?&#39;
        mosaic = next(iter(transaction.transaction.mosaics), &#39;&#39;)
        short_name = f&#39;{status} {transaction.transaction.recipientAddress} | {transaction.meta.height} | {transaction.transaction.deadline} |{message} |{direction}{mosaic} {is_mosaic}&#39;
        short_names[short_name] = transaction
    _short_names = list(short_names.keys())
    _short_names.append(&#39;Exit&#39;)
    while True:
        questions = [
            inquirer.List(
                &#34;transaction&#34;,
                message=&#34;Select an transaction?&#34;,
                choices=_short_names,
                carousel=True
            ),
        ]
        answers = inquirer.prompt(questions)
        transaction = answers[&#39;transaction&#39;]
        if transaction == &#39;Exit&#39;:
            exit(0)
        print(short_names[transaction])</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_init_general_params"><code class="name flex">
<span>def <span class="ident">ui_init_general_params</span></span>(<span>network_type: <a title="nempy.sym.constants.NetworkType" href="sym/constants.html#nempy.sym.constants.NetworkType">NetworkType</a>, accounts_dir: str, is_default: bool = False) ‑> Tuple[str, str, int, bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_init_general_params(network_type: NetworkType, accounts_dir: str, is_default: bool = False) -&gt; Tuple[str, str, int, bool]:
    while True:
        name = input(&#39;Enter the account name: &#39;)
        if name != &#39;&#39;:
            account_path = os.path.join(accounts_dir, name + &#39;.account&#39;)
            if os.path.exists(account_path):
                print(&#39;An account with the same name already exists, please select a different name&#39;)
                continue
            break
        print(&#39;The name cannot be empty.&#39;)
    if not is_default:
        answer = input(f&#39;Set `{name}` account as default? [Y/n]: &#39;) or &#39;y&#39;
        if answer.lower() == &#39;y&#39;:
            is_default = True
    if network_type == NetworkType.MAIN_NET:
        bip32_coin_id = 4343
    elif network_type == NetworkType.TEST_NET:
        bip32_coin_id = 1
    else:
        raise ValueError(&#39;Invalid URL or network not supported&#39;)
    return account_path, name, bip32_coin_id, is_default</code></pre>
</details>
</dd>
<dt id="nempy.ui.AccountUI.ui_keyprint_entropy"><code class="name flex">
<span>def <span class="ident">ui_keyprint_entropy</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_keyprint_entropy():
    random_char_set = &#39;&#39;
    print(&#39;Write something (random character set), the input will be interrupted automatically&#39;)
    attempts = list(range(random.randint(3, 5)))
    for i in attempts:
        something = input(f&#39;Something else ({len(attempts) - i}): &#39;)
        if not something:
            print(&#39;Only a non-empty line will have to be repeated :(&#39;)
            attempts.append(len(attempts))
            continue
        random_char_set += something
    return random_char_set</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.ui.PasswordPolicyError"><code class="flex name class">
<span>class <span class="ident">PasswordPolicyError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PasswordPolicyError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="nempy.ui.ProfileI"><code class="flex name class">
<span>class <span class="ident">ProfileI</span></span>
<span>(</span><span>config_file: str, profiles_dir: str, accounts_dir: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProfileI(UD):

    def __init__(self, config_file: str, profiles_dir: str, accounts_dir: str):
        self.type_ud = UDTypes.PROFILE
        self.account_i = AccountI(config_file, accounts_dir)
        super().__init__(config_file, profiles_dir, None)
        accounts_data = self.load_accounts()
        if (self.account.data is None and accounts_data) \
                or (self.account.data is not None and self.account.data.name not in accounts_data):
            account_data = AccountUI.ui_default_account(accounts_data)
            self.set_default_account(account_data)

    @property
    def data(self) -&gt; Optional[ProfileData]:
        return self.user_data

    def load_profiles(self) -&gt; Dict[str, ProfileData]:
        return self.load_uds()

    def set_default_profile(self, profile: ProfileData):
        self.set_default_ud(profile)

    @property
    def account(self) -&gt; AccountI:
        return self.account_i

    def load_accounts(self) -&gt; Dict[str, AccountData]:
        accounts_data = self.account_i.load_accounts()
        accounts_data = {key: account for key, account in accounts_data.items() if account.profile == self.data.name}
        return accounts_data

    def set_default_account(self, account: AccountData):
        self.account_i.set_default_account(account)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nempy.ui.UD" href="#nempy.ui.UD">UD</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nempy.ui.ProfileUI" href="#nempy.ui.ProfileUI">ProfileUI</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.ProfileI.cls"><code class="name">var <span class="ident">cls</span> : Type[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.ProfileI.type_ud"><code class="name">var <span class="ident">type_ud</span> : <a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.ProfileI.ud_dir"><code class="name">var <span class="ident">ud_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nempy.ui.ProfileI.account"><code class="name">var <span class="ident">account</span> : <a title="nempy.ui.AccountI" href="#nempy.ui.AccountI">AccountI</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def account(self) -&gt; AccountI:
    return self.account_i</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileI.data"><code class="name">var <span class="ident">data</span> : Optional[<a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; Optional[ProfileData]:
    return self.user_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nempy.ui.ProfileI.load_accounts"><code class="name flex">
<span>def <span class="ident">load_accounts</span></span>(<span>self) ‑> Dict[str, <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_accounts(self) -&gt; Dict[str, AccountData]:
    accounts_data = self.account_i.load_accounts()
    accounts_data = {key: account for key, account in accounts_data.items() if account.profile == self.data.name}
    return accounts_data</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileI.load_profiles"><code class="name flex">
<span>def <span class="ident">load_profiles</span></span>(<span>self) ‑> Dict[str, <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_profiles(self) -&gt; Dict[str, ProfileData]:
    return self.load_uds()</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileI.set_default_account"><code class="name flex">
<span>def <span class="ident">set_default_account</span></span>(<span>self, account: <a title="nempy.user_data.AccountData" href="user_data.html#nempy.user_data.AccountData">AccountData</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_account(self, account: AccountData):
    self.account_i.set_default_account(account)</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileI.set_default_profile"><code class="name flex">
<span>def <span class="ident">set_default_profile</span></span>(<span>self, profile: <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_profile(self, profile: ProfileData):
    self.set_default_ud(profile)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.ui.ProfileUI"><code class="flex name class">
<span>class <span class="ident">ProfileUI</span></span>
<span>(</span><span>config_file: str, profiles_dir: str, accounts_dir: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProfileUI(ProfileI):

    @staticmethod
    def ui_default_profile(profiles: Dict[str, ProfileData]) -&gt; ProfileData:
        names = {profile.name + f&#39; [{profile.network_type.name}]&#39;: profile.name for profile in profiles.values()}
        questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default profile&#34;, choices=names.keys(),), ]
        answers = inquirer.prompt(questions)
        if answers is None:
            exit(1)
        name = names[answers[&#39;name&#39;]]
        profile_data = profiles[name]
        network.node_selector.network_type = profile_data.network_type
        return profile_data  # -&gt; set_default_profile(profile)

    @classmethod
    def ui_create_profile(cls, profiles_dir: str, config_file: str) -&gt; Tuple[ProfileData, str]:
        name, path = cls.ui_profile_name(profiles_dir)
        network_type = cls.ui_network_type()
        new_pass = cls.ui_new_pass(10)
        pass_hash = bcrypt.hashpw(new_pass.encode(&#39;utf-8&#39;), bcrypt.gensalt(12))
        accounts_dir = os.path.join(os.path.dirname(profiles_dir), &#39;accounts&#39;)
        profile = ProfileData(name=name,
                              network_type=network_type,
                              pass_hash=pass_hash,
                              accounts_dir=accounts_dir,
                              config_file=config_file)
        return profile, path

    @staticmethod
    def ui_check_pass(profile_data: ProfileData, attempts: int = 1) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Verifies the password from the profile
        :return: password or None if password is failed
        &#34;&#34;&#34;
        for i in range(attempts):
            password = stdiomask.getpass(f&#39;({attempts - i}) Enter your `{profile_data.name} [{profile_data.network_type.name}]` profile password: &#39;)
            if bcrypt.checkpw(password.encode(&#39;utf-8&#39;), profile_data.pass_hash):
                return password
            if i != attempts - 1:
                print(f&#39;Incorrect password. Try again)&#39;)
        logger.error(&#39;Incorrect password&#39;)
        return None

    @staticmethod
    def ui_is_default(name):
        answer = input(f&#39;Set `{name}` profile as default? [Y/n]: &#39;) or &#39;y&#39;
        if answer.lower() == &#39;y&#39;:
            return True
        return False

    @staticmethod
    def ui_profile_name(profiles_dir, attempts: int = 5):
        name = None
        for i in range(attempts):
            name = input(f&#39;({attempts - i}) Enter profile name: &#39;)
            if &#39;.&#39; in name:
                print(&#39;Dot is not a valid character for filename&#39;)
                continue
            path = os.path.join(profiles_dir, f&#39;{name}.profile&#39;)
            if name == &#39;&#39;:
                print(&#39;The name cannot be empty&#39;)
            elif os.path.exists(path):
                print(f&#39;A profile named `{name}` already exists&#39;)
            else:
                return name, path
        raise ValueError(f&#39;Incorrect name for new profile - `{name}`&#39;)

    @staticmethod
    def ui_network_type() -&gt; NetworkType:
        questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an network type?&#34;, choices=[&#34;TEST_NET&#34;, &#34;MAIN_NET&#34;],), ]
        answers = inquirer.prompt(questions)
        network_type = answers[&#39;type&#39;]
        if network_type == &#39;MAIN_NET&#39;:
            network_type = NetworkType.MAIN_NET
        elif network_type == &#39;TEST_NET&#39;:
            network_type = NetworkType.TEST_NET
        else:
            raise TypeError(&#39;Unknown network type&#39;)
        return network_type

    @staticmethod
    def ui_new_pass(n_attempts: int):
        policy = PasswordPolicy.from_names(
            length=8,  # min length: 8
            uppercase=1,  # need min. 1 uppercase letters
            numbers=2,  # need min. 2 digits
            special=1,  # need min. 1 special characters
            nonletters=2,  # need min. 2 non-letter characters (digits, specials, anything)
        )
        new_password = None
        not_in_policies = True
        for i in range(n_attempts):
            new_password = stdiomask.getpass(f&#39;Enter your new account password {policy.test(&#34;&#34;)}: &#39;)
            not_in_policies = policy.test(new_password)
            if not_in_policies:
                print(not_in_policies)
            else:
                break
        if not_in_policies:
            raise PasswordPolicyError(not_in_policies)
        return ProfileUI.ui_repeat_password(n_attempts, new_password)

    @staticmethod
    def ui_repeat_password(n_attempts: int, password):
        for i in range(n_attempts):
            repeat_password = stdiomask.getpass(f&#39;Repeat password for confirmation: &#39;)
            if repeat_password != password:
                print(f&#39;Try again, attempts left {n_attempts - i}&#39;)
            else:
                return password
        raise RepeatPasswordError(&#39;Failed to confirm password on re-entry&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="nempy.ui.ProfileI" href="#nempy.ui.ProfileI">ProfileI</a></li>
<li><a title="nempy.ui.UD" href="#nempy.ui.UD">UD</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.ProfileUI.cls"><code class="name">var <span class="ident">cls</span> : Type[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.ProfileUI.type_ud"><code class="name">var <span class="ident">type_ud</span> : <a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.ProfileUI.ud_dir"><code class="name">var <span class="ident">ud_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nempy.ui.ProfileUI.ui_check_pass"><code class="name flex">
<span>def <span class="ident">ui_check_pass</span></span>(<span>profile_data: <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>, attempts: int = 1) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies the password from the profile
:return: password or None if password is failed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_check_pass(profile_data: ProfileData, attempts: int = 1) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Verifies the password from the profile
    :return: password or None if password is failed
    &#34;&#34;&#34;
    for i in range(attempts):
        password = stdiomask.getpass(f&#39;({attempts - i}) Enter your `{profile_data.name} [{profile_data.network_type.name}]` profile password: &#39;)
        if bcrypt.checkpw(password.encode(&#39;utf-8&#39;), profile_data.pass_hash):
            return password
        if i != attempts - 1:
            print(f&#39;Incorrect password. Try again)&#39;)
    logger.error(&#39;Incorrect password&#39;)
    return None</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_create_profile"><code class="name flex">
<span>def <span class="ident">ui_create_profile</span></span>(<span>profiles_dir: str, config_file: str) ‑> Tuple[<a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ui_create_profile(cls, profiles_dir: str, config_file: str) -&gt; Tuple[ProfileData, str]:
    name, path = cls.ui_profile_name(profiles_dir)
    network_type = cls.ui_network_type()
    new_pass = cls.ui_new_pass(10)
    pass_hash = bcrypt.hashpw(new_pass.encode(&#39;utf-8&#39;), bcrypt.gensalt(12))
    accounts_dir = os.path.join(os.path.dirname(profiles_dir), &#39;accounts&#39;)
    profile = ProfileData(name=name,
                          network_type=network_type,
                          pass_hash=pass_hash,
                          accounts_dir=accounts_dir,
                          config_file=config_file)
    return profile, path</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_default_profile"><code class="name flex">
<span>def <span class="ident">ui_default_profile</span></span>(<span>profiles: Dict[str, <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a>]) ‑> <a title="nempy.user_data.ProfileData" href="user_data.html#nempy.user_data.ProfileData">ProfileData</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_default_profile(profiles: Dict[str, ProfileData]) -&gt; ProfileData:
    names = {profile.name + f&#39; [{profile.network_type.name}]&#39;: profile.name for profile in profiles.values()}
    questions = [inquirer.List(&#34;name&#34;, message=&#34;Select default profile&#34;, choices=names.keys(),), ]
    answers = inquirer.prompt(questions)
    if answers is None:
        exit(1)
    name = names[answers[&#39;name&#39;]]
    profile_data = profiles[name]
    network.node_selector.network_type = profile_data.network_type
    return profile_data  # -&gt; set_default_profile(profile)</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_is_default"><code class="name flex">
<span>def <span class="ident">ui_is_default</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_is_default(name):
    answer = input(f&#39;Set `{name}` profile as default? [Y/n]: &#39;) or &#39;y&#39;
    if answer.lower() == &#39;y&#39;:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_network_type"><code class="name flex">
<span>def <span class="ident">ui_network_type</span></span>(<span>) ‑> <a title="nempy.sym.constants.NetworkType" href="sym/constants.html#nempy.sym.constants.NetworkType">NetworkType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_network_type() -&gt; NetworkType:
    questions = [inquirer.List(&#34;type&#34;, message=&#34;Select an network type?&#34;, choices=[&#34;TEST_NET&#34;, &#34;MAIN_NET&#34;],), ]
    answers = inquirer.prompt(questions)
    network_type = answers[&#39;type&#39;]
    if network_type == &#39;MAIN_NET&#39;:
        network_type = NetworkType.MAIN_NET
    elif network_type == &#39;TEST_NET&#39;:
        network_type = NetworkType.TEST_NET
    else:
        raise TypeError(&#39;Unknown network type&#39;)
    return network_type</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_new_pass"><code class="name flex">
<span>def <span class="ident">ui_new_pass</span></span>(<span>n_attempts: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_new_pass(n_attempts: int):
    policy = PasswordPolicy.from_names(
        length=8,  # min length: 8
        uppercase=1,  # need min. 1 uppercase letters
        numbers=2,  # need min. 2 digits
        special=1,  # need min. 1 special characters
        nonletters=2,  # need min. 2 non-letter characters (digits, specials, anything)
    )
    new_password = None
    not_in_policies = True
    for i in range(n_attempts):
        new_password = stdiomask.getpass(f&#39;Enter your new account password {policy.test(&#34;&#34;)}: &#39;)
        not_in_policies = policy.test(new_password)
        if not_in_policies:
            print(not_in_policies)
        else:
            break
    if not_in_policies:
        raise PasswordPolicyError(not_in_policies)
    return ProfileUI.ui_repeat_password(n_attempts, new_password)</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_profile_name"><code class="name flex">
<span>def <span class="ident">ui_profile_name</span></span>(<span>profiles_dir, attempts: int = 5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_profile_name(profiles_dir, attempts: int = 5):
    name = None
    for i in range(attempts):
        name = input(f&#39;({attempts - i}) Enter profile name: &#39;)
        if &#39;.&#39; in name:
            print(&#39;Dot is not a valid character for filename&#39;)
            continue
        path = os.path.join(profiles_dir, f&#39;{name}.profile&#39;)
        if name == &#39;&#39;:
            print(&#39;The name cannot be empty&#39;)
        elif os.path.exists(path):
            print(f&#39;A profile named `{name}` already exists&#39;)
        else:
            return name, path
    raise ValueError(f&#39;Incorrect name for new profile - `{name}`&#39;)</code></pre>
</details>
</dd>
<dt id="nempy.ui.ProfileUI.ui_repeat_password"><code class="name flex">
<span>def <span class="ident">ui_repeat_password</span></span>(<span>n_attempts: int, password)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ui_repeat_password(n_attempts: int, password):
    for i in range(n_attempts):
        repeat_password = stdiomask.getpass(f&#39;Repeat password for confirmation: &#39;)
        if repeat_password != password:
            print(f&#39;Try again, attempts left {n_attempts - i}&#39;)
        else:
            return password
    raise RepeatPasswordError(&#39;Failed to confirm password on re-entry&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.ui.RepeatPasswordError"><code class="flex name class">
<span>class <span class="ident">RepeatPasswordError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RepeatPasswordError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="nempy.ui.UD"><code class="flex name class">
<span>class <span class="ident">UD</span></span>
<span>(</span><span>config_file: str, profiles_dir: Optional[str], accounts_dir: Optional[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UD:

    cls: Type[UserData]
    type_ud: UDTypes
    ud_dir: str
    config = configparser.ConfigParser()

    def __init__(self, config_file: str, profiles_dir: Optional[str], accounts_dir: Optional[str]):
        self.config_file = config_file
        if self.type_ud == UDTypes.PROFILE:
            self.ud_dir = profiles_dir
            self.cls = ProfileData
        elif self.type_ud == UDTypes.ACCOUNT:
            self.ud_dir = accounts_dir
            self.cls = AccountData

    @property
    def user_data(self) -&gt; Optional[UserData]:
        self.config.read(self.config_file)
        ud_name = self.config[self.type_ud.value][&#39;default&#39;]
        uds = self.load_uds()
        ud = uds.get(ud_name)
        return ud

    def load_uds(self) -&gt; Dict[str, UserData]:
        uds = {}
        profiles_paths = os.listdir(self.ud_dir)
        for pp in profiles_paths:
            path = os.path.join(self.ud_dir, pp)
            ud = self.cls.read(path)
            uds[os.path.splitext(pp)[0]] = ud
        return uds

    def set_default_ud(self, ud: UserData):
        self.config.read(self.config_file)
        self.config[self.type_ud.value][&#39;default&#39;] = ud.name
        with open(self.config_file, &#39;w&#39;) as configfile:
            self.config.write(configfile)

    def get_default_ud_name(self) -&gt; str:
        self.config.read(self.config_file)
        ud_name = self.config[self.type_ud.value][&#39;default&#39;]
        return ud_name</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="nempy.ui.AccountI" href="#nempy.ui.AccountI">AccountI</a></li>
<li><a title="nempy.ui.ProfileI" href="#nempy.ui.ProfileI">ProfileI</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.UD.cls"><code class="name">var <span class="ident">cls</span> : Type[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.UD.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.UD.type_ud"><code class="name">var <span class="ident">type_ud</span> : <a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.UD.ud_dir"><code class="name">var <span class="ident">ud_dir</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nempy.ui.UD.user_data"><code class="name">var <span class="ident">user_data</span> : Optional[<a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_data(self) -&gt; Optional[UserData]:
    self.config.read(self.config_file)
    ud_name = self.config[self.type_ud.value][&#39;default&#39;]
    uds = self.load_uds()
    ud = uds.get(ud_name)
    return ud</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nempy.ui.UD.get_default_ud_name"><code class="name flex">
<span>def <span class="ident">get_default_ud_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_ud_name(self) -&gt; str:
    self.config.read(self.config_file)
    ud_name = self.config[self.type_ud.value][&#39;default&#39;]
    return ud_name</code></pre>
</details>
</dd>
<dt id="nempy.ui.UD.load_uds"><code class="name flex">
<span>def <span class="ident">load_uds</span></span>(<span>self) ‑> Dict[str, <a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_uds(self) -&gt; Dict[str, UserData]:
    uds = {}
    profiles_paths = os.listdir(self.ud_dir)
    for pp in profiles_paths:
        path = os.path.join(self.ud_dir, pp)
        ud = self.cls.read(path)
        uds[os.path.splitext(pp)[0]] = ud
    return uds</code></pre>
</details>
</dd>
<dt id="nempy.ui.UD.set_default_ud"><code class="name flex">
<span>def <span class="ident">set_default_ud</span></span>(<span>self, ud: <a title="nempy.user_data.UserData" href="user_data.html#nempy.user_data.UserData">UserData</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_ud(self, ud: UserData):
    self.config.read(self.config_file)
    self.config[self.type_ud.value][&#39;default&#39;] = ud.name
    with open(self.config_file, &#39;w&#39;) as configfile:
        self.config.write(configfile)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.ui.UDTypes"><code class="flex name class">
<span>class <span class="ident">UDTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UDTypes(Enum):
    PROFILE = &#39;profile&#39;
    ACCOUNT = &#39;account&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.ui.UDTypes.ACCOUNT"><code class="name">var <span class="ident">ACCOUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="nempy.ui.UDTypes.PROFILE"><code class="name">var <span class="ident">PROFILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nempy" href="index.html">nempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="nempy.ui.print_warning" href="#nempy.ui.print_warning">print_warning</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nempy.ui.AccountI" href="#nempy.ui.AccountI">AccountI</a></code></h4>
<ul class="two-column">
<li><code><a title="nempy.ui.AccountI.cls" href="#nempy.ui.AccountI.cls">cls</a></code></li>
<li><code><a title="nempy.ui.AccountI.data" href="#nempy.ui.AccountI.data">data</a></code></li>
<li><code><a title="nempy.ui.AccountI.load_accounts" href="#nempy.ui.AccountI.load_accounts">load_accounts</a></code></li>
<li><code><a title="nempy.ui.AccountI.set_default_account" href="#nempy.ui.AccountI.set_default_account">set_default_account</a></code></li>
<li><code><a title="nempy.ui.AccountI.type_ud" href="#nempy.ui.AccountI.type_ud">type_ud</a></code></li>
<li><code><a title="nempy.ui.AccountI.ud_dir" href="#nempy.ui.AccountI.ud_dir">ud_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.ui.AccountUI" href="#nempy.ui.AccountUI">AccountUI</a></code></h4>
<ul class="">
<li><code><a title="nempy.ui.AccountUI.cls" href="#nempy.ui.AccountUI.cls">cls</a></code></li>
<li><code><a title="nempy.ui.AccountUI.iu_create_account" href="#nempy.ui.AccountUI.iu_create_account">iu_create_account</a></code></li>
<li><code><a title="nempy.ui.AccountUI.save_and_check" href="#nempy.ui.AccountUI.save_and_check">save_and_check</a></code></li>
<li><code><a title="nempy.ui.AccountUI.type_ud" href="#nempy.ui.AccountUI.type_ud">type_ud</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ud_dir" href="#nempy.ui.AccountUI.ud_dir">ud_dir</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_account_by_mnemonic" href="#nempy.ui.AccountUI.ui_account_by_mnemonic">ui_account_by_mnemonic</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_account_inquirer" href="#nempy.ui.AccountUI.ui_account_inquirer">ui_account_inquirer</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_default_account" href="#nempy.ui.AccountUI.ui_default_account">ui_default_account</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_generation_type_inquirer" href="#nempy.ui.AccountUI.ui_generation_type_inquirer">ui_generation_type_inquirer</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_history_inquirer" href="#nempy.ui.AccountUI.ui_history_inquirer">ui_history_inquirer</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_init_general_params" href="#nempy.ui.AccountUI.ui_init_general_params">ui_init_general_params</a></code></li>
<li><code><a title="nempy.ui.AccountUI.ui_keyprint_entropy" href="#nempy.ui.AccountUI.ui_keyprint_entropy">ui_keyprint_entropy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.ui.PasswordPolicyError" href="#nempy.ui.PasswordPolicyError">PasswordPolicyError</a></code></h4>
</li>
<li>
<h4><code><a title="nempy.ui.ProfileI" href="#nempy.ui.ProfileI">ProfileI</a></code></h4>
<ul class="two-column">
<li><code><a title="nempy.ui.ProfileI.account" href="#nempy.ui.ProfileI.account">account</a></code></li>
<li><code><a title="nempy.ui.ProfileI.cls" href="#nempy.ui.ProfileI.cls">cls</a></code></li>
<li><code><a title="nempy.ui.ProfileI.data" href="#nempy.ui.ProfileI.data">data</a></code></li>
<li><code><a title="nempy.ui.ProfileI.load_accounts" href="#nempy.ui.ProfileI.load_accounts">load_accounts</a></code></li>
<li><code><a title="nempy.ui.ProfileI.load_profiles" href="#nempy.ui.ProfileI.load_profiles">load_profiles</a></code></li>
<li><code><a title="nempy.ui.ProfileI.set_default_account" href="#nempy.ui.ProfileI.set_default_account">set_default_account</a></code></li>
<li><code><a title="nempy.ui.ProfileI.set_default_profile" href="#nempy.ui.ProfileI.set_default_profile">set_default_profile</a></code></li>
<li><code><a title="nempy.ui.ProfileI.type_ud" href="#nempy.ui.ProfileI.type_ud">type_ud</a></code></li>
<li><code><a title="nempy.ui.ProfileI.ud_dir" href="#nempy.ui.ProfileI.ud_dir">ud_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.ui.ProfileUI" href="#nempy.ui.ProfileUI">ProfileUI</a></code></h4>
<ul class="two-column">
<li><code><a title="nempy.ui.ProfileUI.cls" href="#nempy.ui.ProfileUI.cls">cls</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.type_ud" href="#nempy.ui.ProfileUI.type_ud">type_ud</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ud_dir" href="#nempy.ui.ProfileUI.ud_dir">ud_dir</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_check_pass" href="#nempy.ui.ProfileUI.ui_check_pass">ui_check_pass</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_create_profile" href="#nempy.ui.ProfileUI.ui_create_profile">ui_create_profile</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_default_profile" href="#nempy.ui.ProfileUI.ui_default_profile">ui_default_profile</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_is_default" href="#nempy.ui.ProfileUI.ui_is_default">ui_is_default</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_network_type" href="#nempy.ui.ProfileUI.ui_network_type">ui_network_type</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_new_pass" href="#nempy.ui.ProfileUI.ui_new_pass">ui_new_pass</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_profile_name" href="#nempy.ui.ProfileUI.ui_profile_name">ui_profile_name</a></code></li>
<li><code><a title="nempy.ui.ProfileUI.ui_repeat_password" href="#nempy.ui.ProfileUI.ui_repeat_password">ui_repeat_password</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.ui.RepeatPasswordError" href="#nempy.ui.RepeatPasswordError">RepeatPasswordError</a></code></h4>
</li>
<li>
<h4><code><a title="nempy.ui.UD" href="#nempy.ui.UD">UD</a></code></h4>
<ul class="two-column">
<li><code><a title="nempy.ui.UD.cls" href="#nempy.ui.UD.cls">cls</a></code></li>
<li><code><a title="nempy.ui.UD.config" href="#nempy.ui.UD.config">config</a></code></li>
<li><code><a title="nempy.ui.UD.get_default_ud_name" href="#nempy.ui.UD.get_default_ud_name">get_default_ud_name</a></code></li>
<li><code><a title="nempy.ui.UD.load_uds" href="#nempy.ui.UD.load_uds">load_uds</a></code></li>
<li><code><a title="nempy.ui.UD.set_default_ud" href="#nempy.ui.UD.set_default_ud">set_default_ud</a></code></li>
<li><code><a title="nempy.ui.UD.type_ud" href="#nempy.ui.UD.type_ud">type_ud</a></code></li>
<li><code><a title="nempy.ui.UD.ud_dir" href="#nempy.ui.UD.ud_dir">ud_dir</a></code></li>
<li><code><a title="nempy.ui.UD.user_data" href="#nempy.ui.UD.user_data">user_data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.ui.UDTypes" href="#nempy.ui.UDTypes">UDTypes</a></code></h4>
<ul class="">
<li><code><a title="nempy.ui.UDTypes.ACCOUNT" href="#nempy.ui.UDTypes.ACCOUNT">ACCOUNT</a></code></li>
<li><code><a title="nempy.ui.UDTypes.PROFILE" href="#nempy.ui.UDTypes.PROFILE">PROFILE</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>