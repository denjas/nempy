<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nempy.sym.api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nempy.sym.api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import hashlib
import logging
import re

from binascii import unhexlify
from typing import Union, Optional, List, Tuple

from symbolchain.core.CryptoTypes import Hash256
from symbolchain.core.CryptoTypes import PrivateKey
from symbolchain.core.CryptoTypes import Signature, PublicKey
from symbolchain.core.facade.SymFacade import SymFacade
from symbolchain.core.sym.IdGenerator import generate_namespace_id

from . import ed25519, network
from .constants import Fees, FM, TransactionTypes, TransactionMetrics, HexSequenceSizes, NetworkType

logger = logging.getLogger(__name__)


class Dividers:
    &#34;&#34;&#34;Accumulates information about dividers for offline work&#34;&#34;&#34;
    dividers = {}

    def __iter__(self):
        for key in self.dividers:
            yield key

    def set(self, key, value):
        self.dividers[key] = value

    def get(self, key):
        return self.dividers.get(key, None)


# class objects as singleton
dividers = Dividers()


class Message(bytes):
    &#34;&#34;&#34;Base class for messages, does the necessary checks&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes], is_encrypted: bool) -&gt; bytes:
        if is_encrypted and not message:
            raise RuntimeError(&#39;Message payload cannot be empty for encrypted message&#39;)
        if len(message) &gt; ed25519.SignClass.PLAIN_MESSAGE_SIZE:
            raise OverflowError(f&#39;Message length cannot exceed {ed25519.SignClass.PLAIN_MESSAGE_SIZE} bytes. Current length: {len(message)}&#39;)
        # # translate into bytes if we sold a string
        if not isinstance(message, bytes):
            message = message.encode()
        return bytes.__new__(bytes, message)


class PlainMessage(bytes):
    &#34;&#34;&#34;Plain messages
    Returns the message as bytes with the necessary flags at the beginning&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes]):
        message = Message(message, False)
        # add the message type code to the beginning of the byte sequence
        if message:
            payload_message = b&#39;\x00&#39; + message
        else:
            payload_message = message
        cls.size = len(payload_message)
        return bytes.__new__(PlainMessage, payload_message)


class EncryptMessage(bytes):
    &#34;&#34;&#34;Encrypted messages requiring additional arguments
    Returns the message as encrypted bytes with the necessary flags at the beginning&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes], sender_private_key: str, recipient_pub: str):
        #  https://docs.symbolplatform.com/concepts/transfer-transaction.html#encrypted-message
        message = Message(message, True)
        hex_encrypted_message = ed25519.Ed25519.encrypt(sender_private_key, recipient_pub, message)
        if len(hex_encrypted_message) &gt; ed25519.SignClass.PLAIN_MESSAGE_SIZE:
            raise OverflowError(f&#39;Encrypted message length cannot exceed {ed25519.SignClass.PLAIN_MESSAGE_SIZE} bytes. Current length: {len(hex_encrypted_message)}&#39;)
        payload_message = b&#39;\x01&#39; + hex_encrypted_message
        cls.size = len(payload_message)
        return bytes.__new__(EncryptMessage, payload_message)


class Namespace(str):
    &#34;&#34;&#34;Building namespace hashes&#34;&#34;&#34;
    def __new__(cls, name: str) -&gt; str:
        ns_sns = name.split(&#39;.&#39;)
        if len(ns_sns) &gt; 3:
            raise ValueError(f&#39;Invalid name for namespace `{name}` - namespaces can have up to 3 levels—a namespace and its two levels of subnamespace domains&#39;)
        namespace_id = 0
        for ns in ns_sns:
            result = re.match(&#39;^[a-z0-9][a-z0-9_-]+$&#39;, ns)
            if len(ns) &gt; 64:
                raise ValueError(f&#39;Invalid name for namespace `{name}` - maximum length of 64 characters&#39;)
            if result is None:
                raise ValueError(f&#39;Invalid name for namespace `{name}` - start with number or letter allowed characters are a, b, c, …, z, 0, 1, 2, …, 9, _ , -&#39;)
            namespace_id = generate_namespace_id(ns, namespace_id)
        return str.__new__(Namespace, hex(namespace_id).upper()[2:])


class Mosaic(tuple):
    &#34;&#34;&#34;Builds a mosaic. Gets additional data by divisor and mosaic ID by name&#34;&#34;&#34;
    def __new__(cls, mosaic_id: str, amount: float):
        cls.size = 16
        if mosaic_id.startswith(&#39;@&#39;):
            mosaic_id = Mosaic.alias_to_mosaic_id(mosaic_id[1:])
        divisibility = Mosaic.get_divisibility(mosaic_id)
        if divisibility is None:
            raise ValueError(f&#39;Failed to get divisibility from network&#39;)
        divider = 10 ** int(divisibility)
        return tuple.__new__(Mosaic, [int(mosaic_id, 16), int(amount * divider)])

    @staticmethod
    def get_divisibility(mosaic_id: str):
        &#34;&#34;&#34;Gets the divisibility by mosaic ID&#34;&#34;&#34;
        if mosaic_id in dividers:
            return dividers.get(mosaic_id)
        else:
            divisibility = network.get_divisibility(mosaic_id)
            if divisibility is not None:
                dividers.set(mosaic_id, divisibility)
            return divisibility

    @staticmethod
    def alias_to_mosaic_id(alis):
        &#34;&#34;&#34;Translates aliases to mosaic id&#34;&#34;&#34;
        namespace_id = Namespace(alis)
        namespace_info = network.get_namespace_info(namespace_id)
        if namespace_info is None or namespace_info == {}:
            raise ValueError(f&#39;Failed to get mosaic_id by name `{alis}`&#39;)
        mosaic_id = namespace_info[&#39;namespace&#39;][&#39;alias&#39;][&#39;mosaicId&#39;]
        return mosaic_id


class Transaction:
    &#34;&#34;&#34;Class for working with transfer transactions&#34;&#34;&#34;

    MIN_TRANSACTION_SIZE = 160  #: Size of transaction with empty message

    def __init__(self):
        self.size: int = -1  #: transaction size
        self.max_fee: int = -1  #: The maximum amount of network currency that the sender of the transaction is willing to pay to get the transaction accepted

        self.network_type: NetworkType = network.get_node_network()
        self.timing: network.Timing = network.Timing(self.network_type)
        self.sym_facade: SymFacade = SymFacade(self.network_type.value)

    def create(self,
               pr_key: str,
               recipient_address: str,
               mosaics: Union[Mosaic, List[Mosaic], None] = None,
               message: Union[PlainMessage, EncryptMessage] = PlainMessage(&#39;&#39;),
               fee_type: Fees = Fees.SLOWEST,
               deadline: Optional[dict] = None) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;Create a transaction&#34;&#34;&#34;

        if deadline is None:
            deadline = {&#39;minutes&#39;: 2}
        if mosaics is None:
            mosaics = []
        if not isinstance(mosaics, list) and isinstance(mosaics, Mosaic):
            mosaics = [mosaics]
        if not isinstance(mosaics, list) and not isinstance(mosaics, Mosaic):
            raise ValueError(f&#39;Expected type of `Mosaic` for mosaic got `{type(mosaics)}`&#39;)
        if len(mosaics) &gt; 1:
            # sorting mosaic by ID (blockchain requirement)
            mosaics = sorted(mosaics, key=lambda tup: tup[0])

        key_pair = self.sym_facade.KeyPair(PrivateKey(unhexlify(pr_key)))

        deadline = self.timing.calc_deadline(**deadline)

        descriptor = {
            &#39;type&#39;: &#39;transfer&#39;,
            &#39;recipient_address&#39;: SymFacade.Address(recipient_address.replace(&#39;-&#39;, &#39;&#39;)).bytes,
            &#39;signer_public_key&#39;: key_pair.public_key,
            &#39;mosaics&#39;: mosaics,
            &#39;fee&#39;: self.max_fee,
            &#39;deadline&#39;: deadline,
            &#39;message&#39;: message
        }

        self.size = self.MIN_TRANSACTION_SIZE + descriptor[&#39;message&#39;].size + sum(mosaic.size for mosaic in descriptor[&#39;mosaics&#39;])
        self.max_fee = Transaction.calc_max_fee(self.size, fee_type)
        descriptor[&#39;fee&#39;] = self.max_fee

        transaction = self.sym_facade.transaction_factory.create(descriptor)

        signature = self.sym_facade.sign_transaction(key_pair, transaction)
        entity_hash = Transaction.entity_hash_gen(signature, key_pair.public_key, transaction,
                                                  self.sym_facade.network.generation_hash_seed)

        payload_bytes = self.sym_facade.transaction_factory.attach_signature(transaction, signature)

        # print(transaction)
        # print(hexlify(transaction.serialize()))
        # print(answer.status_code, answer.text)
        logger.debug(f&#39;Transaction hash: {entity_hash}&#39;)

        return entity_hash, payload_bytes

    @staticmethod
    def calc_max_fee(transaction_size: int, fee_type: Fees):
        &#34;&#34;&#34;Calculation of the transaction fee&#34;&#34;&#34;
        # network fee multipliers
        nfm = network.get_fee_multipliers()
        if nfm is None:
            raise ValueError(f&#39;Failed to get fee multipliers from network. Unable to calculate fee&#39;)
        # https://github.com/nemgrouplimited/symbol-desktop-wallet/blob/507d4694a0ff55b0b039be0b5d061b47b2386fde/src/services/TransactionCommand.ts#L200
        fast_fee_multiplier = nfm[FM.min] if nfm[FM.average] &lt; nfm[FM.min] else nfm[FM.average]
        average_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.65
        slow_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.35
        slowest_fee_multiplier = nfm[FM.min]
        # sometimes the average is less than fast
        slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier = sorted(
            [slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier])

        div = 1000000
        logger.debug(f&#39;Fees.FAST.name: {fast_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.AVERAGE.name: {average_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.SLOW.name: {slow_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.SLOWEST.name: {slowest_fee_multiplier * transaction_size / div}&#39;)

        fee_multiplier = None
        if fee_type == Fees.FAST:
            fee_multiplier = fast_fee_multiplier
        if fee_type == Fees.AVERAGE:
            fee_multiplier = average_fee_multiplier
        if fee_type == Fees.SLOW:
            fee_multiplier = slow_fee_multiplier
        if fee_type == Fees.SLOWEST:
            fee_multiplier = slowest_fee_multiplier
        if fee_type == Fees.ZERO:
            fee_multiplier = 0

        max_fee = int(fee_multiplier * transaction_size)
        # TODO whether restrictions are needed for too high a fee, can this be?
        return max_fee

    @staticmethod
    def entity_hash_gen(signature: Signature, public_key: PublicKey, transaction, generation_hash: Hash256):
        &#34;&#34;&#34;Calculate the transaction hash by applying SHA3-256 hashing algorithm to the first 32 bytes of signature,
        the signer public key, nemesis block generation hash, and the remaining transaction payload.&#34;&#34;&#34;
        # https://symbol-docs.netlify.app/concepts/transaction.html
        tr_sr = transaction.serialize()
        is_aggregate = transaction.type in [TransactionTypes.AGGREGATE_BONDED, TransactionTypes.AGGREGATE_COMPLETE]
        # TODO check if it works correctly on aggregated transactions
        if is_aggregate:
            raise NotImplementedError(&#39;Working with aggregated transactions has not been tested !!!&#39;)
            transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:TransactionMetrics.TRANSACTION_BODY_INDEX + 32]
        else:
            transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:]
        # https://symbol-docs.netlify.app/concepts/transaction.html#signing-a-transaction
        entity_hash_bytes = b&#39;&#39;.join([signature.bytes, public_key.bytes, generation_hash.bytes, transaction_body])
        # entity_hash = Hash256(hashlib.sha3_256(entity_hash_bytes).digest())
        entity_hash = hashlib.sha3_256(entity_hash_bytes).hexdigest().upper()
        return entity_hash</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nempy.sym.api.Dividers"><code class="flex name class">
<span>class <span class="ident">Dividers</span></span>
</code></dt>
<dd>
<div class="desc"><p>Accumulates information about dividers for offline work</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dividers:
    &#34;&#34;&#34;Accumulates information about dividers for offline work&#34;&#34;&#34;
    dividers = {}

    def __iter__(self):
        for key in self.dividers:
            yield key

    def set(self, key, value):
        self.dividers[key] = value

    def get(self, key):
        return self.dividers.get(key, None)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nempy.sym.api.Dividers.dividers"><code class="name">var <span class="ident">dividers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nempy.sym.api.Dividers.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key):
    return self.dividers.get(key, None)</code></pre>
</details>
</dd>
<dt id="nempy.sym.api.Dividers.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, key, value):
    self.dividers[key] = value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.sym.api.EncryptMessage"><code class="flex name class">
<span>class <span class="ident">EncryptMessage</span></span>
<span>(</span><span>message: Union[str, bytes], sender_private_key: str, recipient_pub: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypted messages requiring additional arguments
Returns the message as encrypted bytes with the necessary flags at the beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EncryptMessage(bytes):
    &#34;&#34;&#34;Encrypted messages requiring additional arguments
    Returns the message as encrypted bytes with the necessary flags at the beginning&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes], sender_private_key: str, recipient_pub: str):
        #  https://docs.symbolplatform.com/concepts/transfer-transaction.html#encrypted-message
        message = Message(message, True)
        hex_encrypted_message = ed25519.Ed25519.encrypt(sender_private_key, recipient_pub, message)
        if len(hex_encrypted_message) &gt; ed25519.SignClass.PLAIN_MESSAGE_SIZE:
            raise OverflowError(f&#39;Encrypted message length cannot exceed {ed25519.SignClass.PLAIN_MESSAGE_SIZE} bytes. Current length: {len(hex_encrypted_message)}&#39;)
        payload_message = b&#39;\x01&#39; + hex_encrypted_message
        cls.size = len(payload_message)
        return bytes.__new__(EncryptMessage, payload_message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
</ul>
</dd>
<dt id="nempy.sym.api.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>message: Union[str, bytes], is_encrypted: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for messages, does the necessary checks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message(bytes):
    &#34;&#34;&#34;Base class for messages, does the necessary checks&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes], is_encrypted: bool) -&gt; bytes:
        if is_encrypted and not message:
            raise RuntimeError(&#39;Message payload cannot be empty for encrypted message&#39;)
        if len(message) &gt; ed25519.SignClass.PLAIN_MESSAGE_SIZE:
            raise OverflowError(f&#39;Message length cannot exceed {ed25519.SignClass.PLAIN_MESSAGE_SIZE} bytes. Current length: {len(message)}&#39;)
        # # translate into bytes if we sold a string
        if not isinstance(message, bytes):
            message = message.encode()
        return bytes.__new__(bytes, message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
</ul>
</dd>
<dt id="nempy.sym.api.Mosaic"><code class="flex name class">
<span>class <span class="ident">Mosaic</span></span>
<span>(</span><span>mosaic_id: str, amount: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds a mosaic. Gets additional data by divisor and mosaic ID by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mosaic(tuple):
    &#34;&#34;&#34;Builds a mosaic. Gets additional data by divisor and mosaic ID by name&#34;&#34;&#34;
    def __new__(cls, mosaic_id: str, amount: float):
        cls.size = 16
        if mosaic_id.startswith(&#39;@&#39;):
            mosaic_id = Mosaic.alias_to_mosaic_id(mosaic_id[1:])
        divisibility = Mosaic.get_divisibility(mosaic_id)
        if divisibility is None:
            raise ValueError(f&#39;Failed to get divisibility from network&#39;)
        divider = 10 ** int(divisibility)
        return tuple.__new__(Mosaic, [int(mosaic_id, 16), int(amount * divider)])

    @staticmethod
    def get_divisibility(mosaic_id: str):
        &#34;&#34;&#34;Gets the divisibility by mosaic ID&#34;&#34;&#34;
        if mosaic_id in dividers:
            return dividers.get(mosaic_id)
        else:
            divisibility = network.get_divisibility(mosaic_id)
            if divisibility is not None:
                dividers.set(mosaic_id, divisibility)
            return divisibility

    @staticmethod
    def alias_to_mosaic_id(alis):
        &#34;&#34;&#34;Translates aliases to mosaic id&#34;&#34;&#34;
        namespace_id = Namespace(alis)
        namespace_info = network.get_namespace_info(namespace_id)
        if namespace_info is None or namespace_info == {}:
            raise ValueError(f&#39;Failed to get mosaic_id by name `{alis}`&#39;)
        mosaic_id = namespace_info[&#39;namespace&#39;][&#39;alias&#39;][&#39;mosaicId&#39;]
        return mosaic_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="nempy.sym.api.Mosaic.alias_to_mosaic_id"><code class="name flex">
<span>def <span class="ident">alias_to_mosaic_id</span></span>(<span>alis)</span>
</code></dt>
<dd>
<div class="desc"><p>Translates aliases to mosaic id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def alias_to_mosaic_id(alis):
    &#34;&#34;&#34;Translates aliases to mosaic id&#34;&#34;&#34;
    namespace_id = Namespace(alis)
    namespace_info = network.get_namespace_info(namespace_id)
    if namespace_info is None or namespace_info == {}:
        raise ValueError(f&#39;Failed to get mosaic_id by name `{alis}`&#39;)
    mosaic_id = namespace_info[&#39;namespace&#39;][&#39;alias&#39;][&#39;mosaicId&#39;]
    return mosaic_id</code></pre>
</details>
</dd>
<dt id="nempy.sym.api.Mosaic.get_divisibility"><code class="name flex">
<span>def <span class="ident">get_divisibility</span></span>(<span>mosaic_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the divisibility by mosaic ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_divisibility(mosaic_id: str):
    &#34;&#34;&#34;Gets the divisibility by mosaic ID&#34;&#34;&#34;
    if mosaic_id in dividers:
        return dividers.get(mosaic_id)
    else:
        divisibility = network.get_divisibility(mosaic_id)
        if divisibility is not None:
            dividers.set(mosaic_id, divisibility)
        return divisibility</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="nempy.sym.api.Namespace"><code class="flex name class">
<span>class <span class="ident">Namespace</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Building namespace hashes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Namespace(str):
    &#34;&#34;&#34;Building namespace hashes&#34;&#34;&#34;
    def __new__(cls, name: str) -&gt; str:
        ns_sns = name.split(&#39;.&#39;)
        if len(ns_sns) &gt; 3:
            raise ValueError(f&#39;Invalid name for namespace `{name}` - namespaces can have up to 3 levels—a namespace and its two levels of subnamespace domains&#39;)
        namespace_id = 0
        for ns in ns_sns:
            result = re.match(&#39;^[a-z0-9][a-z0-9_-]+$&#39;, ns)
            if len(ns) &gt; 64:
                raise ValueError(f&#39;Invalid name for namespace `{name}` - maximum length of 64 characters&#39;)
            if result is None:
                raise ValueError(f&#39;Invalid name for namespace `{name}` - start with number or letter allowed characters are a, b, c, …, z, 0, 1, 2, …, 9, _ , -&#39;)
            namespace_id = generate_namespace_id(ns, namespace_id)
        return str.__new__(Namespace, hex(namespace_id).upper()[2:])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
</dd>
<dt id="nempy.sym.api.PlainMessage"><code class="flex name class">
<span>class <span class="ident">PlainMessage</span></span>
<span>(</span><span>message: Union[str, bytes])</span>
</code></dt>
<dd>
<div class="desc"><p>Plain messages
Returns the message as bytes with the necessary flags at the beginning</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlainMessage(bytes):
    &#34;&#34;&#34;Plain messages
    Returns the message as bytes with the necessary flags at the beginning&#34;&#34;&#34;
    def __new__(cls, message: Union[str, bytes]):
        message = Message(message, False)
        # add the message type code to the beginning of the byte sequence
        if message:
            payload_message = b&#39;\x00&#39; + message
        else:
            payload_message = message
        cls.size = len(payload_message)
        return bytes.__new__(PlainMessage, payload_message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="nempy.sym.api.PlainMessage.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="nempy.sym.api.Transaction"><code class="flex name class">
<span>class <span class="ident">Transaction</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class for working with transfer transactions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transaction:
    &#34;&#34;&#34;Class for working with transfer transactions&#34;&#34;&#34;

    MIN_TRANSACTION_SIZE = 160  #: Size of transaction with empty message

    def __init__(self):
        self.size: int = -1  #: transaction size
        self.max_fee: int = -1  #: The maximum amount of network currency that the sender of the transaction is willing to pay to get the transaction accepted

        self.network_type: NetworkType = network.get_node_network()
        self.timing: network.Timing = network.Timing(self.network_type)
        self.sym_facade: SymFacade = SymFacade(self.network_type.value)

    def create(self,
               pr_key: str,
               recipient_address: str,
               mosaics: Union[Mosaic, List[Mosaic], None] = None,
               message: Union[PlainMessage, EncryptMessage] = PlainMessage(&#39;&#39;),
               fee_type: Fees = Fees.SLOWEST,
               deadline: Optional[dict] = None) -&gt; Tuple[str, bytes]:
        &#34;&#34;&#34;Create a transaction&#34;&#34;&#34;

        if deadline is None:
            deadline = {&#39;minutes&#39;: 2}
        if mosaics is None:
            mosaics = []
        if not isinstance(mosaics, list) and isinstance(mosaics, Mosaic):
            mosaics = [mosaics]
        if not isinstance(mosaics, list) and not isinstance(mosaics, Mosaic):
            raise ValueError(f&#39;Expected type of `Mosaic` for mosaic got `{type(mosaics)}`&#39;)
        if len(mosaics) &gt; 1:
            # sorting mosaic by ID (blockchain requirement)
            mosaics = sorted(mosaics, key=lambda tup: tup[0])

        key_pair = self.sym_facade.KeyPair(PrivateKey(unhexlify(pr_key)))

        deadline = self.timing.calc_deadline(**deadline)

        descriptor = {
            &#39;type&#39;: &#39;transfer&#39;,
            &#39;recipient_address&#39;: SymFacade.Address(recipient_address.replace(&#39;-&#39;, &#39;&#39;)).bytes,
            &#39;signer_public_key&#39;: key_pair.public_key,
            &#39;mosaics&#39;: mosaics,
            &#39;fee&#39;: self.max_fee,
            &#39;deadline&#39;: deadline,
            &#39;message&#39;: message
        }

        self.size = self.MIN_TRANSACTION_SIZE + descriptor[&#39;message&#39;].size + sum(mosaic.size for mosaic in descriptor[&#39;mosaics&#39;])
        self.max_fee = Transaction.calc_max_fee(self.size, fee_type)
        descriptor[&#39;fee&#39;] = self.max_fee

        transaction = self.sym_facade.transaction_factory.create(descriptor)

        signature = self.sym_facade.sign_transaction(key_pair, transaction)
        entity_hash = Transaction.entity_hash_gen(signature, key_pair.public_key, transaction,
                                                  self.sym_facade.network.generation_hash_seed)

        payload_bytes = self.sym_facade.transaction_factory.attach_signature(transaction, signature)

        # print(transaction)
        # print(hexlify(transaction.serialize()))
        # print(answer.status_code, answer.text)
        logger.debug(f&#39;Transaction hash: {entity_hash}&#39;)

        return entity_hash, payload_bytes

    @staticmethod
    def calc_max_fee(transaction_size: int, fee_type: Fees):
        &#34;&#34;&#34;Calculation of the transaction fee&#34;&#34;&#34;
        # network fee multipliers
        nfm = network.get_fee_multipliers()
        if nfm is None:
            raise ValueError(f&#39;Failed to get fee multipliers from network. Unable to calculate fee&#39;)
        # https://github.com/nemgrouplimited/symbol-desktop-wallet/blob/507d4694a0ff55b0b039be0b5d061b47b2386fde/src/services/TransactionCommand.ts#L200
        fast_fee_multiplier = nfm[FM.min] if nfm[FM.average] &lt; nfm[FM.min] else nfm[FM.average]
        average_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.65
        slow_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.35
        slowest_fee_multiplier = nfm[FM.min]
        # sometimes the average is less than fast
        slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier = sorted(
            [slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier])

        div = 1000000
        logger.debug(f&#39;Fees.FAST.name: {fast_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.AVERAGE.name: {average_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.SLOW.name: {slow_fee_multiplier * transaction_size / div}&#39;)
        logger.debug(f&#39;Fees.SLOWEST.name: {slowest_fee_multiplier * transaction_size / div}&#39;)

        fee_multiplier = None
        if fee_type == Fees.FAST:
            fee_multiplier = fast_fee_multiplier
        if fee_type == Fees.AVERAGE:
            fee_multiplier = average_fee_multiplier
        if fee_type == Fees.SLOW:
            fee_multiplier = slow_fee_multiplier
        if fee_type == Fees.SLOWEST:
            fee_multiplier = slowest_fee_multiplier
        if fee_type == Fees.ZERO:
            fee_multiplier = 0

        max_fee = int(fee_multiplier * transaction_size)
        # TODO whether restrictions are needed for too high a fee, can this be?
        return max_fee

    @staticmethod
    def entity_hash_gen(signature: Signature, public_key: PublicKey, transaction, generation_hash: Hash256):
        &#34;&#34;&#34;Calculate the transaction hash by applying SHA3-256 hashing algorithm to the first 32 bytes of signature,
        the signer public key, nemesis block generation hash, and the remaining transaction payload.&#34;&#34;&#34;
        # https://symbol-docs.netlify.app/concepts/transaction.html
        tr_sr = transaction.serialize()
        is_aggregate = transaction.type in [TransactionTypes.AGGREGATE_BONDED, TransactionTypes.AGGREGATE_COMPLETE]
        # TODO check if it works correctly on aggregated transactions
        if is_aggregate:
            raise NotImplementedError(&#39;Working with aggregated transactions has not been tested !!!&#39;)
            transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:TransactionMetrics.TRANSACTION_BODY_INDEX + 32]
        else:
            transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:]
        # https://symbol-docs.netlify.app/concepts/transaction.html#signing-a-transaction
        entity_hash_bytes = b&#39;&#39;.join([signature.bytes, public_key.bytes, generation_hash.bytes, transaction_body])
        # entity_hash = Hash256(hashlib.sha3_256(entity_hash_bytes).digest())
        entity_hash = hashlib.sha3_256(entity_hash_bytes).hexdigest().upper()
        return entity_hash</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="nempy.sym.api.Transaction.MIN_TRANSACTION_SIZE"><code class="name">var <span class="ident">MIN_TRANSACTION_SIZE</span></code></dt>
<dd>
<div class="desc"><p>Size of transaction with empty message</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="nempy.sym.api.Transaction.calc_max_fee"><code class="name flex">
<span>def <span class="ident">calc_max_fee</span></span>(<span>transaction_size: int, fee_type: <a title="nempy.sym.constants.Fees" href="constants.html#nempy.sym.constants.Fees">Fees</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculation of the transaction fee</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_max_fee(transaction_size: int, fee_type: Fees):
    &#34;&#34;&#34;Calculation of the transaction fee&#34;&#34;&#34;
    # network fee multipliers
    nfm = network.get_fee_multipliers()
    if nfm is None:
        raise ValueError(f&#39;Failed to get fee multipliers from network. Unable to calculate fee&#39;)
    # https://github.com/nemgrouplimited/symbol-desktop-wallet/blob/507d4694a0ff55b0b039be0b5d061b47b2386fde/src/services/TransactionCommand.ts#L200
    fast_fee_multiplier = nfm[FM.min] if nfm[FM.average] &lt; nfm[FM.min] else nfm[FM.average]
    average_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.65
    slow_fee_multiplier = nfm[FM.min] + nfm[FM.average] * 0.35
    slowest_fee_multiplier = nfm[FM.min]
    # sometimes the average is less than fast
    slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier = sorted(
        [slowest_fee_multiplier, slow_fee_multiplier, average_fee_multiplier, fast_fee_multiplier])

    div = 1000000
    logger.debug(f&#39;Fees.FAST.name: {fast_fee_multiplier * transaction_size / div}&#39;)
    logger.debug(f&#39;Fees.AVERAGE.name: {average_fee_multiplier * transaction_size / div}&#39;)
    logger.debug(f&#39;Fees.SLOW.name: {slow_fee_multiplier * transaction_size / div}&#39;)
    logger.debug(f&#39;Fees.SLOWEST.name: {slowest_fee_multiplier * transaction_size / div}&#39;)

    fee_multiplier = None
    if fee_type == Fees.FAST:
        fee_multiplier = fast_fee_multiplier
    if fee_type == Fees.AVERAGE:
        fee_multiplier = average_fee_multiplier
    if fee_type == Fees.SLOW:
        fee_multiplier = slow_fee_multiplier
    if fee_type == Fees.SLOWEST:
        fee_multiplier = slowest_fee_multiplier
    if fee_type == Fees.ZERO:
        fee_multiplier = 0

    max_fee = int(fee_multiplier * transaction_size)
    # TODO whether restrictions are needed for too high a fee, can this be?
    return max_fee</code></pre>
</details>
</dd>
<dt id="nempy.sym.api.Transaction.entity_hash_gen"><code class="name flex">
<span>def <span class="ident">entity_hash_gen</span></span>(<span>signature: symbolchain.core.CryptoTypes.Signature, public_key: symbolchain.core.CryptoTypes.PublicKey, transaction, generation_hash: symbolchain.core.CryptoTypes.Hash256)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the transaction hash by applying SHA3-256 hashing algorithm to the first 32 bytes of signature,
the signer public key, nemesis block generation hash, and the remaining transaction payload.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def entity_hash_gen(signature: Signature, public_key: PublicKey, transaction, generation_hash: Hash256):
    &#34;&#34;&#34;Calculate the transaction hash by applying SHA3-256 hashing algorithm to the first 32 bytes of signature,
    the signer public key, nemesis block generation hash, and the remaining transaction payload.&#34;&#34;&#34;
    # https://symbol-docs.netlify.app/concepts/transaction.html
    tr_sr = transaction.serialize()
    is_aggregate = transaction.type in [TransactionTypes.AGGREGATE_BONDED, TransactionTypes.AGGREGATE_COMPLETE]
    # TODO check if it works correctly on aggregated transactions
    if is_aggregate:
        raise NotImplementedError(&#39;Working with aggregated transactions has not been tested !!!&#39;)
        transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:TransactionMetrics.TRANSACTION_BODY_INDEX + 32]
    else:
        transaction_body = tr_sr[TransactionMetrics.TRANSACTION_HEADER_SIZE:]
    # https://symbol-docs.netlify.app/concepts/transaction.html#signing-a-transaction
    entity_hash_bytes = b&#39;&#39;.join([signature.bytes, public_key.bytes, generation_hash.bytes, transaction_body])
    # entity_hash = Hash256(hashlib.sha3_256(entity_hash_bytes).digest())
    entity_hash = hashlib.sha3_256(entity_hash_bytes).hexdigest().upper()
    return entity_hash</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="nempy.sym.api.Transaction.max_fee"><code class="name">var <span class="ident">max_fee</span></code></dt>
<dd>
<div class="desc"><p>The maximum amount of network currency that the sender of the transaction is willing to pay to get the transaction accepted</p></div>
</dd>
<dt id="nempy.sym.api.Transaction.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>transaction size</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="nempy.sym.api.Transaction.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, pr_key: str, recipient_address: str, mosaics: Union[<a title="nempy.sym.api.Mosaic" href="#nempy.sym.api.Mosaic">Mosaic</a>, List[<a title="nempy.sym.api.Mosaic" href="#nempy.sym.api.Mosaic">Mosaic</a>], ForwardRef(None)] = None, message: Union[<a title="nempy.sym.api.PlainMessage" href="#nempy.sym.api.PlainMessage">PlainMessage</a>, <a title="nempy.sym.api.EncryptMessage" href="#nempy.sym.api.EncryptMessage">EncryptMessage</a>] = b'', fee_type: <a title="nempy.sym.constants.Fees" href="constants.html#nempy.sym.constants.Fees">Fees</a> = Fees.SLOWEST, deadline: Optional[dict] = None) ‑> Tuple[str, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self,
           pr_key: str,
           recipient_address: str,
           mosaics: Union[Mosaic, List[Mosaic], None] = None,
           message: Union[PlainMessage, EncryptMessage] = PlainMessage(&#39;&#39;),
           fee_type: Fees = Fees.SLOWEST,
           deadline: Optional[dict] = None) -&gt; Tuple[str, bytes]:
    &#34;&#34;&#34;Create a transaction&#34;&#34;&#34;

    if deadline is None:
        deadline = {&#39;minutes&#39;: 2}
    if mosaics is None:
        mosaics = []
    if not isinstance(mosaics, list) and isinstance(mosaics, Mosaic):
        mosaics = [mosaics]
    if not isinstance(mosaics, list) and not isinstance(mosaics, Mosaic):
        raise ValueError(f&#39;Expected type of `Mosaic` for mosaic got `{type(mosaics)}`&#39;)
    if len(mosaics) &gt; 1:
        # sorting mosaic by ID (blockchain requirement)
        mosaics = sorted(mosaics, key=lambda tup: tup[0])

    key_pair = self.sym_facade.KeyPair(PrivateKey(unhexlify(pr_key)))

    deadline = self.timing.calc_deadline(**deadline)

    descriptor = {
        &#39;type&#39;: &#39;transfer&#39;,
        &#39;recipient_address&#39;: SymFacade.Address(recipient_address.replace(&#39;-&#39;, &#39;&#39;)).bytes,
        &#39;signer_public_key&#39;: key_pair.public_key,
        &#39;mosaics&#39;: mosaics,
        &#39;fee&#39;: self.max_fee,
        &#39;deadline&#39;: deadline,
        &#39;message&#39;: message
    }

    self.size = self.MIN_TRANSACTION_SIZE + descriptor[&#39;message&#39;].size + sum(mosaic.size for mosaic in descriptor[&#39;mosaics&#39;])
    self.max_fee = Transaction.calc_max_fee(self.size, fee_type)
    descriptor[&#39;fee&#39;] = self.max_fee

    transaction = self.sym_facade.transaction_factory.create(descriptor)

    signature = self.sym_facade.sign_transaction(key_pair, transaction)
    entity_hash = Transaction.entity_hash_gen(signature, key_pair.public_key, transaction,
                                              self.sym_facade.network.generation_hash_seed)

    payload_bytes = self.sym_facade.transaction_factory.attach_signature(transaction, signature)

    # print(transaction)
    # print(hexlify(transaction.serialize()))
    # print(answer.status_code, answer.text)
    logger.debug(f&#39;Transaction hash: {entity_hash}&#39;)

    return entity_hash, payload_bytes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nempy.sym" href="index.html">nempy.sym</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nempy.sym.api.Dividers" href="#nempy.sym.api.Dividers">Dividers</a></code></h4>
<ul class="">
<li><code><a title="nempy.sym.api.Dividers.dividers" href="#nempy.sym.api.Dividers.dividers">dividers</a></code></li>
<li><code><a title="nempy.sym.api.Dividers.get" href="#nempy.sym.api.Dividers.get">get</a></code></li>
<li><code><a title="nempy.sym.api.Dividers.set" href="#nempy.sym.api.Dividers.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.sym.api.EncryptMessage" href="#nempy.sym.api.EncryptMessage">EncryptMessage</a></code></h4>
</li>
<li>
<h4><code><a title="nempy.sym.api.Message" href="#nempy.sym.api.Message">Message</a></code></h4>
</li>
<li>
<h4><code><a title="nempy.sym.api.Mosaic" href="#nempy.sym.api.Mosaic">Mosaic</a></code></h4>
<ul class="">
<li><code><a title="nempy.sym.api.Mosaic.alias_to_mosaic_id" href="#nempy.sym.api.Mosaic.alias_to_mosaic_id">alias_to_mosaic_id</a></code></li>
<li><code><a title="nempy.sym.api.Mosaic.get_divisibility" href="#nempy.sym.api.Mosaic.get_divisibility">get_divisibility</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.sym.api.Namespace" href="#nempy.sym.api.Namespace">Namespace</a></code></h4>
</li>
<li>
<h4><code><a title="nempy.sym.api.PlainMessage" href="#nempy.sym.api.PlainMessage">PlainMessage</a></code></h4>
<ul class="">
<li><code><a title="nempy.sym.api.PlainMessage.size" href="#nempy.sym.api.PlainMessage.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="nempy.sym.api.Transaction" href="#nempy.sym.api.Transaction">Transaction</a></code></h4>
<ul class="">
<li><code><a title="nempy.sym.api.Transaction.MIN_TRANSACTION_SIZE" href="#nempy.sym.api.Transaction.MIN_TRANSACTION_SIZE">MIN_TRANSACTION_SIZE</a></code></li>
<li><code><a title="nempy.sym.api.Transaction.calc_max_fee" href="#nempy.sym.api.Transaction.calc_max_fee">calc_max_fee</a></code></li>
<li><code><a title="nempy.sym.api.Transaction.create" href="#nempy.sym.api.Transaction.create">create</a></code></li>
<li><code><a title="nempy.sym.api.Transaction.entity_hash_gen" href="#nempy.sym.api.Transaction.entity_hash_gen">entity_hash_gen</a></code></li>
<li><code><a title="nempy.sym.api.Transaction.max_fee" href="#nempy.sym.api.Transaction.max_fee">max_fee</a></code></li>
<li><code><a title="nempy.sym.api.Transaction.size" href="#nempy.sym.api.Transaction.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>